<!--  ==== COMMUNITY CHAT (PocketBase + Tailwind) ====  -->
<div id="pb-chat" style="min-height:600px"></div>

<!-- Tailwind ‚îÄ loads instantly from the official CDN -->
<script src="https://cdn.tailwindcss.com"></script>

<script type="module">
/* ----------------------------------------------------
   CONFIGURATION
---------------------------------------------------- */
import PocketBase from "https://cdn.jsdelivr.net/npm/pocketbase/+esm";
import { html, render } from "https://cdn.jsdelivr.net/npm/lit-html/+esm";

console.log("module executed");   // sanity check
const PB_URL = "https://pocketbase-yxsc.onrender.com";          //  ‚Üê change me
const pb     = new PocketBase(PB_URL);

/* ----------------------------------------------------
   STATE  /  SIMPLE STORE
---------------------------------------------------- */
const state = {
  user     : pb.authStore.model,
  channels : [],
  current  : null,
  messages : [],
  pinned   : [],      //  ‚Üê  NEW: always at least an empty array
  msgSub   : null
};

const setState = (obj)=>{ Object.assign(state,obj); draw(); };

/* ------- pin-banner helper state ------- */
let pinTimer   = null;        // rotation interval
let pinIndex   = 0;           // which pinned msg is showing
let pinExpanded = false;      // banner is unfolded?


/* ----------------------------------------------------
   RENDER LOOP
---------------------------------------------------- */
function draw(){ render(state.user ? chatUI() : authUI(),
                        document.getElementById("pb-chat")); }

/* ---------- AUTH SCREENS ---------- */
function authUI(){
  return html`
  <div class="max-w-md mx-auto my-12 p-6 bg-white rounded-xl shadow">
    <h2 class="text-xl font-semibold mb-4 text-center">Member Login</h2>
    <form @submit=${loginEmail} class="space-y-3">
      <input name="email"    type="email"    placeholder="Email"
             required class="w-full p-2 border rounded">
      <input name="password" type="password" placeholder="Password"
             required class="w-full p-2 border rounded">
      <button class="w-full py-2 bg-indigo-600 text-white rounded">Log&nbsp;in</button>
    </form>
    ${state.loginErr ? html`
  <p class="mt-2 text-center text-red-600 text-sm">${state.loginErr}</p>` : ""}
    <p class="text-sm text-center mt-4">
      No account?
      <a @click=${()=>setState({showSignup:true})}
         class="text-indigo-600 cursor-pointer">Sign up</a>
    </p>
    ${state.showSignup ? signupForm() : ""}
  </div>`; }

function signupForm(){ return html`
  <form @submit=${signupEmail} class="space-y-3 mt-4 border-t pt-4">
+   <input name="fullname" placeholder="Full name" required
+          class="w-full p-2 border rounded">
    <input name="display"  placeholder="Display name" required
           class="w-full p-2 border rounded">
    <input name="email"    type="email"    placeholder="Email"    required
           class="w-full p-2 border rounded">
    <input name="password" type="password" placeholder="Password" required
           class="w-full p-2 border rounded">
    <button class="w-full py-2 bg-green-600 text-white rounded">
      Create&nbsp;account
    </button>
  </form>`; }


async function loginEmail(e){
  e.preventDefault();
  const f = Object.fromEntries(new FormData(e.target));
  try{
    await pb.collection("users").authWithPassword(f.email, f.password);
    setState({ user: pb.authStore.model, showSignup:false, loginErr:null });
    loadChannels();
  }catch(err){
    /* show a friendly message under the form */
    setState({ loginErr:"Wrong e-mail or password" });
  }
}
async function signupEmail(e){
  e.preventDefault();
  const f = Object.fromEntries(new FormData(e.target));   // collect all 4 values

  await pb.collection("users").create({
    email           : f.email,
    password        : f.password,
    passwordConfirm : f.password,
    name            : f.fullname,     // real name (auth collection already has ‚Äúname‚Äù)
    displayName     : f.display,      // public nickname
    role            : "member"
  });

  /* immediately log-in the new user */
  await loginEmail({ preventDefault(){}, target:e.target });
}


/* ---------- CHAT SCREENS ---------- */
function chatUI(){
  return html`
  <div class="flex h-[600px] border rounded overflow-hidden bg-gray-50">
    <!-- channels -->
    <aside class="w-56 bg-gray-100 border-r overflow-y-auto">
      <header class="p-3 font-semibold flex justify-between items-center">
        Channels
        ${isMod()? html`<button @click=${createChannel}>+</button>` : ""}
      </header>
      ${state.channels.map(c=>html`
        <div
  class="group p-3 cursor-pointer flex justify-between
         ${state.current?.id===c.id?'bg-white font-semibold':''}"
>
  <span @click=${()=>switchChannel(c)}># ${c.name}</span>

  ${isMod() ? html`
    <span class="opacity-0 group-hover:opacity-100 space-x-1 text-xs">
      <button @click=${()=>renameChannel(c)}   class="text-indigo-600">‚úé</button>
      <button @click=${()=>deleteChannel(c)}  class="text-red-600">üóë</button>
    </span>` : ""}
</div>`)}
    </aside>

    <!-- messages + composer -->
    <main class="flex-1 flex flex-col">
      <header class="p-3 border-b bg-white font-semibold">
        ${state.current ? `#${state.current.name}` : "select a channel"}
        <button @click=${logout}
                class="float-right text-red-600 text-sm">Log&nbsp;out</button>
      </header>

      <section id="msgwrap"
         class="relative flex-1 p-4 overflow-y-auto space-y-3 bg-white">

     ${state.pinned.length ? html`
  <div class="sticky top-0 z-10  /* <-- NEW */
            border border-indigo-300 bg-indigo-50
            rounded-md px-3 py-1
            text-sm cursor-pointer select-none
            overflow-hidden whitespace-nowrap text-ellipsis"
     @click=${togglePinBanner}>
  üìå ${truncate(state.pinned[pinIndex]?.text || "[image]")}
</div>` : ""}


        ${state.messages.filter(m=>m.pinned).map(renderMsg)}
        ${state.messages.filter(m=>!m.pinned).map(renderMsg)}
      </section>

      ${state.current ? msgComposer() : ""}
    </main>
  </div>`; }

function renderMsg(m){
  // full user record if expand is present; otherwise just the ID string
  const user = m.expand?.author ?? m.author;
  const you  = (typeof user === "object") && user.id === state.user.id;

  /* ---------- avatar (image or initials) ---------- */
let avatarEl;

if (typeof user === "object" && user.avatar) {
  // Auth-user files live under the internal bucket ‚Äú_pb_users_auth_‚Äù
  const avatarSrc =
    `${PB_URL}/api/files/_pb_users_auth_/${user.id}/${user.avatar}?thumb=64x64`;

  avatarEl = html`
    <img class="w-10 h-10 rounded-full" src=${avatarSrc} alt="avatar">`;
} else {
  // fallback: grey circle with initials
  const name      = typeof user === "object"
                      ? user.displayName || user.email || "??"
                      : "??";
  const initials  = name.slice(0, 2).toUpperCase();

  avatarEl = html`
    <div class="w-10 h-10 rounded-full flex items-center justify-center
                bg-gray-300 text-xs font-semibold">
      ${initials}
    </div>`;
}

  /* attached image (optional) */
 const firstFile = Array.isArray(m.image) ? m.image[0] : m.image;
 const imageEl   = firstFile
     ? html`<img class="max-w-xs rounded mt-2"
                 src=${pb.files.getURL(m, firstFile, { thumb:"640x640" })}>`
     : "";


  /* ---------- role badge ---------- */
let roleBadge = "";
if (typeof user === "object") {
  if (user.role === "admin") {
    roleBadge = html`
      <span class="ml-1 text-xs font-semibold text-green-600">
        (ADMIN)
      </span>`;
  } else if (user.role === "moderator") {
    roleBadge = html`
      <span class="ml-1 text-xs font-semibold text-green-600">
        (MOD)
      </span>`;
  }
}


  /* ---------- template ---------- */
  return html`
  <article class="flex gap-3" id="m-${m.id}">
    ${avatarEl}

    <div class="flex-1">
      <header class="text-sm mb-1">
        <span class="font-semibold">
          ${typeof user === "object"
              ? user.displayName || user.email
              : user       /* ‚Üê unlikely, but safe */}
        </span>
        ${roleBadge}

        <time class="ml-2 text-gray-500 text-xs">
           ${new Date(m.created).toLocaleString([], {
       year:  'numeric',
       month: '2-digit',
       day:   '2-digit',
       hour:  '2-digit',
       minute:'2-digit'
   })}
        </time>

        ${(isMod() || you)
          ? html`<button @click=${()=>delMsg(m)}
                   class="ml-2 text-red-600 text-xs">Deleteüóë</button>` : ""}
        ${isMod()
          ? html`<button @click=${()=>pinMsg(m)}
                   class="ml-2 text-xs">${m.pinned ? "Unpinüìå" : "Pinüìå"}</button>` : ""}
      </header>

      ${m.text ? html`<p class="whitespace-pre-wrap">${m.text}</p>` : ""}
      ${imageEl}
    </div>
  </article>`;
}




/* ---------- composer with live preview (pretty paper-clip) ---------- */
function msgComposer() {
  return html`
    <form @submit=${sendMsg}
          class="flex flex-col gap-2 border-t p-3 bg-gray-50">

      <!-- preview (hidden until a file is chosen) -->
      <div id="imgPreview" class="hidden flex items-center gap-2">
        <img   id="imgThumb" class="w-16 h-16 rounded object-cover">
        <span  id="imgName"  class="text-sm text-gray-700"></span>
        <button type="button" @click=${clearImage}
                class="text-red-600 text-xs">‚úï</button>
      </div>

      <div class="flex gap-3">
        <input  name="text" placeholder="Message‚Ä¶" autocomplete="off"
                class="flex-1 p-2 border rounded">

        <!-- hidden file input -->
        <input  id="imgInput" name="image" type="file" accept="image/*"
                class="hidden" @change=${showPreview} >

        <!-- prettier paper-clip -->
        <button type="button"
                @click=${() => document.getElementById("imgInput").click()}
                class="w-10 h-10 flex items-center justify-center
                       rounded hover:bg-indigo-50 active:bg-indigo-100
                       transition">
          <!-- hero-icons outline paper-clip (24√ó24) -->
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
  <path stroke-linecap="round" stroke-linejoin="round" d="m18.375 12.739-7.693 7.693a4.5 4.5 0 0 1-6.364-6.364l10.94-10.94A3 3 0 1 1 19.5 7.372L8.552 18.32m.009-.01-.01.01m5.699-9.941-7.81 7.81a1.5 1.5 0 0 0 2.112 2.13" />
</svg>

        </button>

        <button class="px-4 py-2 bg-indigo-600 text-white rounded
                       hover:bg-indigo-700 transition">
          Send
        </button>
      </div>
    </form>`;
}


/* ---------- ACTIONS ---------- */
async function createChannel(){
  const name = prompt("Channel name (no spaces)");
  if(!name) return;
  const chan = await pb.collection("channels")
                       .create({ name, createdBy:state.user.id });
  await refreshChannels(chan.id);
}
   
function switchChannel(c){
 if (state.current?.id === c.id) return;   // already there
 if (typeof state.msgSub === "function") {         // stop SSE for old channel
   state.msgSub(); 
 }
  /* clear the view immediately for snappier feedback */
  setState({ current:c, messages:[], pinned:[] });

  /* then load the new channel‚Äôs history */
  loadMessages(c.id);
}

   /* render ONE channel row  ‚Äì  whole row is clickable,
   but the ‚úé / üóë icons stop the click bubbling */
function channelRow(c){
  const isCurrent = c.id === state.current?.id;

  return html`
    <div
      class="group flex justify-between items-center p-3
             cursor-pointer ${isCurrent ? 'bg-white font-semibold' : ''}"
      @click=${() => switchChannel(c)}
    >
      <span># ${c.name}</span>

      ${isMod() ? html`
        <span class="opacity-0 group-hover:opacity-100 space-x-1 text-xs">
          <button  @click=${e => {e.stopPropagation(); renameChannel(c);} }
                   class="text-indigo-600">‚úé</button>
          <button  @click=${e => {e.stopPropagation(); deleteChannel(c);} }
                   class="text-red-600">üóë</button>
        </span>` : ""}
    </div>`;
}


async function renameChannel(chan){
  const name = prompt("New channel name", chan.name);
  if(!name || name === chan.name) return;
  await pb.collection("channels").update(chan.id, { name });
  await refreshChannels(chan.id);
}

async function deleteChannel(chan){
  if(!confirm(`Delete #${chan.name}?  All its messages will be removed.`)) return;
  await pb.collection("channels").delete(chan.id);

  /* after deletion pick first remaining channel (if any) */
  await refreshChannels(state.channels[0]?.id);
}
   
/* ---- helper: show preview when a file is picked ---- */
function showPreview(e){
  const file = e.target.files[0];
  if (!file) return clearImage();

  const url   = URL.createObjectURL(file);
  imgThumb.src      = url;
  imgName.textContent = file.name;
  imgPreview.classList.remove("hidden");
}

/* ---- helper: clear the chosen file ---- */
function clearImage(){
  const input = document.getElementById("imgInput");
  input.value = "";          // reset <input type="file">
  imgPreview.classList.add("hidden");
}

   /* ---- shorten long texts for the banner ---- */
function truncate(str, max = 110) {
  if (!str) return "";
  return str.length > max ? str.slice(0, max) + "‚Ä¶" : str;
}

/* ---- toggle banner expansion ---- */
function togglePinBanner() {
  pinExpanded = !pinExpanded;
  if (pinExpanded) {
    // show modal with all pinned messages
    showPinnedModal();
  }
}

/* ---- modal viewer ---- */
function showPinnedModal() {
  /* back-drop */
  const modal = document.createElement("div");
  modal.className =
    "fixed inset-0 z-50 bg-black/40 flex items-center justify-center";

  /* white card ----------------------------------------------- */
  const card = document.createElement("div");
  card.className =
    "bg-white rounded-xl max-h-[80vh] w-[90vw] max-w-lg p-4 overflow-y-auto";
  modal.appendChild(card);

  /* close btn */
  const close = () => document.body.removeChild(modal);
  card.innerHTML = `
      <h2 class="text-lg font-semibold mb-4">Pinned messages</h2>
      <div id="pinList" class="space-y-4"></div>
      <button id="pinClose"
              class="mt-4 px-4 py-2 bg-indigo-600 text-white rounded
                     mx-auto block">Close</button>`;
  card.querySelector("#pinClose").onclick = close;

  /* render the list with Lit ------------------------------- */
  const listHost = card.querySelector("#pinList");
  render(state.pinned.map(renderMsg), listHost);

  /* mount */
  document.body.appendChild(modal);
}


   
/* ---------- send message with error handling ---------- */
async function sendMsg(e){
  e.preventDefault();

  const fd = new FormData(e.target);
  fd.set("channel", state.current.id);
  fd.set("author",  state.user.id);

  // trim empty text and image
  if (!fd.get("text").trim())              fd.delete("text");
  if (!fd.get("image") || fd.get("image").size === 0) fd.delete("image");

  try {
      /*  create the stub record; we DON'T push it to the UI  */
      await pb.collection("messages").create(fd);

      /*  clear form + preview immediately  */
      e.target.reset();
      clearImage();

  } catch (err){
      alert(err?.message || "Failed to send message.");   // validation, size, etc.
      console.error(err);
  }
}
   
async function delMsg(m){ if(confirm("Delete message?"))
  await pb.collection("messages").delete(m.id); }
async function pinMsg(m){
  await pb.collection("messages").update(m.id,{pinned:!m.pinned});
}
function logout(){
  pb.authStore.clear();
  setState({user:null,channels:[],current:null,messages:[]});
}
const isMod = ()=>["moderator","admin"].includes(state.user?.role);

/* quick helper: refresh the channel list after any CRUD op */
async function refreshChannels(selectId = null){
  state.channels = await pb.collection("channels").getFullList({ sort:"name" });
setState({});                       // re-render list first

  if (selectId){
    const hit = state.channels.find(c => c.id === selectId);
    if (hit) switchChannel(hit);      // then actually switch
  }
}

/* ---------- DATA LOADERS ---------- */
async function loadChannels(){
  const list = await pb.collection("channels").getFullList({sort:"name"});
  setState({channels:list});
  if(list.length) switchChannel(list[0]);
}
   
/* ----------------------------------------------------
   fetch all messages for the selected channel,
   normalise them, compute the pinned list,
   then subscribe for realtime updates
---------------------------------------------------- */
async function loadMessages(channelId){

  /* 1Ô∏è‚É£  grab everything that already exists */
  let list = await pb.collection("messages").getFullList({
    filter : `channel='${channelId}'`,
    expand : "author",
    sort   : "-pinned,created"
  });

  /* 2Ô∏è‚É£  legacy fix: replace ‚Äúimage‚Äù placeholders with the real filename */
  await Promise.all(
    list.map(async (m,i) => {
      const needsFix =
        m.image === "image" ||
        (Array.isArray(m.image) && m.image[0] === "image");

      if (needsFix) {
        list[i] = await pb.collection("messages")
                          .getOne(m.id, { expand:"author" });
      }
    })
  );

  /* 3Ô∏è‚É£  normalise: ensure m.image is a *single* filename string */
  list.forEach(m => {
    if (Array.isArray(m.image)) m.image = m.image[0] || "";
  });

  /* 4Ô∏è‚É£  compute the pinned list and push everything into state */
  const pinned = list
    .filter(m => m.pinned)
    .sort((a,b) => new Date(a.created) - new Date(b.created));

  setState({ messages:list, pinned });

  /* 5Ô∏è‚É£  (re)start the 3-second rotation of the banner */
  startPinRotation();

  /* 6Ô∏è‚É£  subscribe to realtime changes ‚Äî **await** because the
          fixed subscribeMessages is now async and returns a promise */
  await subscribeMessages(channelId);

  /* 7Ô∏è‚É£  scroll to the bottom once the DOM has rendered */
  setTimeout(() => {
    const wrap = document.getElementById("msgwrap");
    if (wrap) wrap.scrollTop = wrap.scrollHeight;
  }); 
  subscribeMessages(channelId);
  setTimeout(()=>document.getElementById("msgwrap").scrollTop = 9e9);
}
   
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
/* only ONE copy of this function in the file     */
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
async function subscribeMessages(channelId){
  /* ‚ù∂ store the unsubscribe fn that .subscribe returns */
  state.msgSub = await pb.collection("messages").subscribe(
    "*",

    /* ‚ù∑ realtime event-handler */
    async ev => {
      /* upsert helper ------------------------------ */
      const upsert = rec => {
        const i = state.messages.findIndex(x => x.id === rec.id);
        i === -1 ? state.messages.push(rec)
                 : state.messages[i] = rec;
      };

      /* CREATE ------------------------------------ */
      if (ev.action === "create") {
        let rec = ev.record;
        if (!rec.image || rec.image === "image") {
          rec = await pb.collection("messages")
                        .getOne(rec.id, { expand:"author" });
        }
        if (Array.isArray(rec.image)) rec.image = rec.image[0] || "";
        upsert(rec);

      /* UPDATE ------------------------------------ */
      } else if (ev.action === "update") {
        let rec = ev.record;
        if (!rec.image || rec.image === "image") {
          rec = await pb.collection("messages")
                        .getOne(rec.id, { expand:"author" });
        }
        if (Array.isArray(rec.image)) rec.image = rec.image[0] || "";
        upsert(rec);

      /* DELETE ------------------------------------ */
      } else if (ev.action === "delete") {
        state.messages = state.messages.filter(x => x.id !== ev.record.id);
      }

      /* recompute pinned -------------------------- */
      state.pinned = state.messages
        .filter(m => m.pinned)
        .sort((a,b) => new Date(a.created) - new Date(b.created));
      startPinRotation();

      /* smart-scroll ------------------------------ */
      const wrap     = document.getElementById("msgwrap");
      const atBottom = wrap &&
        (wrap.scrollHeight - wrap.scrollTop - wrap.clientHeight < 40);

      setState({ messages: state.messages, pinned: state.pinned });

      if (atBottom && wrap) wrap.scrollTop = wrap.scrollHeight;
    },

    /* subscribe options */
    { filter:`channel='${channelId}'`, expand:"author" }
  );
}



function startPinRotation() {
  clearInterval(pinTimer);
  if (state.pinned.length <= 1) return;
  pinIndex = 0;
  pinTimer = setInterval(() => {
    pinIndex = (pinIndex + 1) % state.pinned.length;
    draw();
  }, 3000);
}





/* ---------- INIT ---------- */
if(state.user) loadChannels();
draw();
</script>
<!--  ================================================  -->
